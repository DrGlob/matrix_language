## Представление блочной матрицы как иерархии матриц

Для работы с огромными матрицами используется представление в виде **матрицы матриц** — иерархической структуры, где матрица рекурсивно разбивается на блоки. Это позволяет:

1. **Эффективное хранение**: работа только с необходимыми блоками в памяти
2. **Оптимальные вычисления**: применение алгоритмов типа Штрассена для блоков
3. **Параллелизм**: независимая обработка блоков

### Ключевые задачи:
- Переработать представление матрицы на древовидную структуру
- Разработать алгоритм разбиения с учётом кэш-локальности
- Реализовать блочное умножение с параллельным выполнением операций

```kotlin
suspend fun multiplyStrassen(a: MatrixNode, b: MatrixNode): MatrixNode = coroutineScope {
    if (a.rows <= THRESHOLD) {
        // Наивное умножение листьев
        naiveMultiply(a as MatrixNode.Leaf, b as MatrixNode.Leaf)
    } else {
        val (a11, a12, a21, a22) = split(a)
        val (b11, b12, b21, b22) = split(b)
        
        // Параллельные сложения для входов
        val p1 = async { add(a11, a22) }
        val q1 = async { add(b11, b22) }
        // ... аналогично для других (A21+A22, etc.)
        
        // Затем 7 умножений
        val m1 = async { multiplyStrassen(p1.await(), q1.await()) }
        val m2 = async { multiplyStrassen(add(a21, a22), b11) } // и т.д. для m3-m7
        
        // Ждём все m
        val m1Res = m1.await()
        // ...
        
        // Затем 4 сложения для C
        val c11 = async { add(add(m1Res, m4Res), subtract(subtract(m7Res, m5Res))) } // Пример комбинации
        // Аналогично для c12, c21, c22
        
        MatrixNode.Internal(c11.await(), c12.await(), c21.await(), c22.await())
    }
}
```

## От чего зависит размер блока
- размер кэша процессора

### Реализация умножения по Штрассену в Kotlin
Пример кода для параллельного умножения матриц по алгоритму Штрассена:
Этот код демонстрирует, как интегрировать рекурсию, coroutines и блочное разбиение для эффективного умножения. Он дополняет переработку операций, обеспечивая параллелизм на уровне подзадач.
```Kotlin
suspend fun multiplyStrassen(a: MatrixNode, b: MatrixNode): MatrixNode = coroutineScope {
    if (a.rows <= THRESHOLD) {
        // Наивное умножение листьев
        naiveMultiply(a as MatrixNode.Leaf, b as MatrixNode.Leaf)
    } else {
        val (a11, a12, a21, a22) = split(a)
        val (b11, b12, b21, b22) = split(b)
        
        // Параллельные сложения для входов (пример для p1 и q1; расширить для остальных)
        val p1 = async { add(a11, a22) }
        val q1 = async { add(b11, b22) }
        val p2 = async { add(a21, a22) }
        // ... аналогично для p3-p7 (A11, A22, etc. комбинации)
        
        // 7 параллельных умножений
        val m1 = async { multiplyStrassen(p1.await(), q1.await()) }
        val m2 = async { multiplyStrassen(p2.await(), b11) }
        val m3 = async { multiplyStrassen(a11, subtract(b12, b22)) }
        val m4 = async { multiplyStrassen(a22, subtract(b21, b11)) }
        val m5 = async { multiplyStrassen(add(a11, a12), b22) }
        val m6 = async { multiplyStrassen(subtract(a21, a11), add(b11, b12)) }
        val m7 = async { multiplyStrassen(subtract(a12, a22), add(b21, b22)) }
        
        // Ждём результаты умножений
        val m1Res = m1.await()
        val m2Res = m2.await()
        val m3Res = m3.await()
        val m4Res = m4.await()
        val m5Res = m5.await()
        val m6Res = m6.await()
        val m7Res = m7.await()
        
        // 4 параллельных сложения для C (комбинации по Штрассену)
        val c11 = async { add(subtract(add(m1Res, m4Res), m5Res), m7Res) }
        val c12 = async { add(m3Res, m5Res) }
        val c21 = async { add(m2Res, m4Res) }
        val c22 = async { add(add(subtract(m1Res, m2Res), m3Res), m6Res) }
        
        MatrixNode.Internal(c11.await(), c12.await(), c21.await(), c22.await())
    }
}